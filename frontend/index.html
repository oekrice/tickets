<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Oliver's Split Ticket Finder</title>
    <link rel="stylesheet" href="style.css">

</head>

<body style="font-family:arial">
    <div>Find train ticket information between two stations. <br></b>
         Input your requirements and if it's a reasonable request it'll tell you some things. <br>
        With sincere apologies for the slowness -- I don't want to pay for the API. <br>
        Try not to click the buttons again until the results have fnished loading.</div>
    <hr>
    <div>
        <label for="origin-input">Origin Station:</label>
        <input  list="station-list" id="origin-input" placeholder = "Durham (DHM)"> 
        <datalist id="station-list">
    </div>
    <div>
        <label for="destination-input">Destination Station:</label>
        <input  list="station-list" id="destination-input"  placeholder = "York (YRK)"> 
    </div>
    <div>
        <label for="date-input">Date of Travel:</label>
        <!-- Need to obtain date bounds here. Not trivial-->        
        <input type="date" id="date-input">
    </div>
    <div>
        <label for="depart-time-input">Depart After:</label>
        <input type="time" id="depart-time-input">
    </div>
    <div>
        <label for="arrive-time-input">Arrive Before:</label>
        <input type="time" id="arrive-time-input">
    </div>

    <hr>
    <div>
        <button onclick=getTrains(0)>Get 'direct' trains</button>
        <button onclick=getTrains(1)>Get basic split tickets</button>
        <button onclick=getTrains(2)>Get detailed split tickets</button>
    </div>
    <hr>
    <div id="status-container"></div>
    <div id="sort-options">
        <p> Sort results by: <br>
        <button onclick=sortTrains(0)>Departure Time</button>
        <button onclick=sortTrains(1)>Price</button>
        <button onclick=sortTrains(2)>Journey Time</button>
        <button onclick=sortTrains(3)>Value</button>
        </p>
    </div>

    <div id="result-container"></div>
    <table id="outputTable" style="display:none" >
        <tr>
            <th>Departs</th>
            <th>Arrives</th>
            <th>Price</th>
            <th>Journey Time</th>
            <th>Changes</th>
        </tr>
    </table>

    </div>
</body>
<script>
    "use strict";
    let xhr = null;
    let originStation, destinationStation
    let trainDate, departTime, arriveTime
    let inputParameters
    let trainDataRaw, trainData, existingData
    let stationData
    let detailFlag = false
    let sortOptionSet = 0
    if (trainData == null){
        trainData = []
    }
    //Update default parameters in the search bar (date etc.) and obtain the list of allowed stations
    document.getElementById("sort-options").style.display = "none"
    getDefaults();  

    async function loadTest() {
    const response = await fetch('./testdata.json');
    const data = await response.json();
    return data;
    }

    //THIS IS FOR TESTING -- COMMENT OUT TO USE NORMALLY
    // loadTest().then(data => {
    //     trainData = data;
    //     console.log('datalength a', trainData.length)

    //     makeResultTable(trainData)
    //     document.getElementById("outputTable").style.display = "block"
    //     document.getElementById("sort-options").style.display = "block";
    
    // })

    function sortTrains(sortOption){
        //Sorts the results in place based on the selected option 
        //Either departure time (the default), price or a made up 'value' function
        var sortValues = []
        if (sortOption == 0){
            //This is departure time. Make an array of the values to be sorted
            //Want to sort by arrival time first, for reasons
        for (let i = 0; i < trainData.length; i ++){
            sortValues.push(parseFloat(trainData[i].arr_time))
        }

        const paired = trainData.map((item, i) => [item, sortValues[i]]);
        paired.sort((a, b) => a[1] - b[1]);
        trainData = paired.map(pair => pair[0]);

        var sortValues = []

        for (let i = 0; i < trainData.length; i ++){
            sortValues.push(parseFloat(trainData[i].dep_time))
        }
        } else if (sortOption == 1) {
            //This is price. Make an array of the values to be sorted
            for (let i = 0; i < trainData.length; i ++){
                sortValues.push(parseFloat(trainData[i].price))
        } 
        } else if (sortOption == 2) {
            for (let i = 0; i < trainData.length; i ++){
                let journeyTime = findJourneyTime(trainData[i].dep_time, trainData[i].arr_time)
                sortValues.push(journeyTime)
        }
        } else if (sortOption == 3) {
            for (let i = 0; i < trainData.length; i ++){
                let journeyTime = findJourneyTime(trainData[i].dep_time, trainData[i].arr_time)
                let journeyMinutes = journeyTime.getUTCMinutes() + journeyTime.getUTCHours()*60
                let value = trainData[i].price + 5.0*journeyMinutes/60
                sortValues.push(value)
        }
        }
        sortOptionSet = sortOption
        const paired = trainData.map((item, i) => [item, sortValues[i]]);
        paired.sort((a, b) => a[1] - b[1]);
        trainData = paired.map(pair => pair[0]);
        makeResultTable(trainData);

    }

    async function getTrains(requestStatus) {
        //Send the parameters to Python and wait for a response...
        //let requestStatus = 1

        //If requestStatus is 0 or 1, this is simple. If not, it needs to be in a loop to obtain stations in due course. 

        if (requestStatus < 2){
            let dataToSend = packageInputData(requestStatus, 0);   //This also gives a message to the output lump. Currently unsure where we tell the output lump to get its thing but meh.
            let resultInfo 
            let parser, xmlDoc
            parser = new DOMParser()
            // console.log(dataToSend);
            if (!dataToSend) {
                console.log("Insufficient data entered. Aborting.");
                return;
            }

            try {
                // Send the POST request
                const response = await fetch("/trains", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json;charset=UTF-8"
                    },
                    body: JSON.stringify(dataToSend)
                });

                if (response.status === 201) {
                    // console.log("Data creation response received!");
                    trainDataRaw = await response.text();
                    trainData = JSON.parse(trainDataRaw)  //Object containing the train outputs
                    xmlDoc = parser.parseFromString(trainDataRaw,"text/xml")
                    //At this point trigger a function to enable the HTML to make a nice table of the results
                    sortTrains(sortOptionSet)   //This also makes the data table so don't need to add it below any more
                    //makeResultTable(trainData)

                    //If no results found, say as much and don't display the table
                    if (trainData.length == 0) {
                        resultInfo = "No trains found."
                    } else {
                        resultInfo = trainData.length.toString() + " trains found between " + String(originStation) + " and " + String(destinationStation) + ". Click for more info."
                        document.getElementById("outputTable").style.display = "block";
                        document.getElementById("sort-options").style.display = "block";
                    }
                    document.getElementById("status-container").innerHTML = resultInfo;

                    //document.getElementById('result-container').innerHTML = trainDataRaw;  //This is the bit which actually updates the result text, which is probably as a string. Would be better as an object...
                } else {
                    resultInfo = 'Request failed for some reason. Try something else?'
                    document.getElementById("status-container").innerHTML = resultInfo;
                    console.error("Request failed with status:", response.status);
                }
            } catch (error) {
                resultInfo = "It appears that the server isn't running. Bugger.  <br> Please let me know (if you're not me)."
                document.getElementById("status-container").innerHTML = resultInfo;
                console.error("Network error:", error);
            }

        } else {
            document.getElementById("status-container").innerHTML = "Attempting continual updates."
            //Send initial request as per?
            let i = 0
            let resultInfo 
            let dataToSend
            let parser, xmlDoc
            while (i < 11){
                dataToSend = packageInputData(requestStatus, i);   //This also gives a message to the output lump. Currently unsure where we tell the output lump to get its thing but meh.
                parser = new DOMParser()
                existingData = trainData
                if (!dataToSend) {
                    console.log("Insufficient data entered. Aborting.");
                    return;
                }

                try {
                    // Send the POST request
                    const response = await fetch("/trains", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json;charset=UTF-8"
                        },
                        body: JSON.stringify(dataToSend)
                    });

                    if (response.status === 201) {
                        // console.log("Data creation response received!");
                        trainDataRaw = await response.text();
                        trainData = JSON.parse(trainDataRaw)  //Object containing the train outputs
                        xmlDoc = parser.parseFromString(trainDataRaw,"text/xml")
                        //At this point trigger a function to enable the HTML to make a nice table of the results

                        //If no results found, say as much and don't display the table
                        if (trainData.length == 0 && existingData.length == 0) {
                            resultInfo = "No trains found."
                        } else if (trainData.length > 0) {
                            resultInfo = 'Still finding trains... Currently found ' + trainData.length.toString() + " trains between " + String(originStation) + " and " + String(destinationStation) + ".<br>Wait a bit longer and these might get cheaper. Click for more info."
                            document.getElementById("outputTable").style.display = "block";
                            document.getElementById("sort-options").style.display = "block";
                        document.getElementById("status-container").innerHTML = resultInfo;
                            sortTrains(sortOptionSet)   //This also makes the data table
                            //makeResultTable(trainData)
                        } else if (trainData.length == 0 && existingData.length > 0) {   //This is done now. Just leave it as is if possible.
                            resultInfo = 'Finished. ' + existingData.length.toString() + " trains found between " + String(originStation) + " and " + String(destinationStation) + ". Click for more info."
                            document.getElementById("outputTable").style.display = "block";
                            document.getElementById("sort-options").style.display = "block";
                            trainData = existingData
                        }   
                        document.getElementById("status-container").innerHTML = resultInfo;
                    } else {                             
                        resultInfo = 'The code might still be running, or the scraper may have been thwarted. Wait and see I guess...'
                        document.getElementById("status-container").innerHTML = resultInfo;
                        console.error("Request failed with status:", response.status);
                    }
                } catch (error) {
                    resultInfo = "It appears that the server isn't running. Bugger.  <br> Please let me know (if you're not me)."
                    document.getElementById("status-container").innerHTML = resultInfo;
                    console.error("Network error:", error);
                }
                if (trainData.length == 0) break;   //Whatever has happened before, it's time to stop
                i ++
            }
            //Finish off with a message
            resultInfo = 'Finished. ' + existingData.length.toString() + " trains found between " + String(originStation) + " and " + String(destinationStation) + ". Click for more info."
            document.getElementById("status-container").innerHTML = resultInfo;

            //Need to figure out how many stations to check here (can definitely specify in due course). Perhaps a timeout is wise to stop sending requests?
        }
    }

    function toTime(rawTime){
        //Just a simple function to convert a raw time to a hh:mm etc.
        if (rawTime.length == 4) {
            return String(rawTime).substring(0,2) + ":" + String(rawTime).substring(2,4);
        } else {
            return "0" + String(rawTime).substring(0,1) + ":" + String(rawTime).substring(1,3);
        }
    }

    function toPrice(rawPrice){
        //Just a simple function to convert price to the correct format
        if (rawPrice < 10){
            return " £" + rawPrice.toFixed(2);
        } else {
            return "£" + rawPrice.toFixed(2);
        }
    }

    function getDefaults(){

        //Get default parameters for the search fields (current time until midnight)
        let today = new Date();
        let fivemins = new Date();
        let threehours = new Date();
        fivemins.setMinutes(fivemins.getMinutes() + 15)
        threehours.setMinutes(threehours.getMinutes() + 180)
        let todayString = today.toISOString().split('T')[0];
        let timeString = String(fivemins.getHours()).padStart(2,'0') + ":" + String(fivemins.getMinutes()).padStart(2,'0')
        document.getElementById('date-input').value = todayString;
        document.getElementById('date-input').min = todayString;
        //document.getElementById('depart-time-input').min = timeString;
        document.getElementById('depart-time-input').value = timeString;
        timeString = String(threehours.getHours()).padStart(2,'0') + ":" + String(threehours.getMinutes()).padStart(2,'0')
        document.getElementById('arrive-time-input').value = timeString;
        //document.getElementById('arrive-time-input').min = timeString;

        //Add a bit which can get the list of stations (obtained from the dictionary file)
        async function loadStations() {
        const response = await fetch('./station_info.json');
        const data = await response.json();
        return data;
        }

        loadStations().then(stationData => {
            stationData;
            let stationTitle, fullTitle
            let options = ""
            //Populate the station data as soon as this is loaded? I think that might be what you're meant to do with these things... Async is a bit funny
            for (const key in stationData){
                stationTitle = stationData[key].station_name.substring(0,stationData[key].station_name.length-13) + " (" + key + ")"
                options +=  "<option value='" + stationTitle +"'>"
            }
            document.getElementById('station-list').innerHTML = options;
        })




    }

    function updateTimeBounds(){
        //If the arrive time changes etc., then make sure departure isn't after it. May be a tad tricky to get all the possibilities here...
        //If today then make sure depart time is greater than now, but not otherwise
        let today = new Date();
        let todayString = today.toISOString().split('T')[0];
        let timeString = today.getHours() + ":" + today.getMinutes()
        if (document.getElementById('date-input').value == todayString){
            document.getElementById('date-input').min = todayString;
        } else {
            document.getElementById('date-input').min = "00:00";
        }
    }

    function findJourneyTime(depTime, arrTime){
        //Using the departure and arrival time in the standard string format, output the journey time.
        let time1 = new Date();
        let time2 = new Date();
        let timeDiff = new Date();
        time1.setHours(depTime.substring(0,2));
        time1.setMinutes(depTime.substring(2,4));
        time2.setHours(arrTime.substring(0,2));
        time2.setMinutes(arrTime.substring(2,4));
        timeDiff = new Date(time2 - time1);
        return timeDiff;
    }

    function makeResultTable(trainData){
        //Uses the raw train Data and outputs in a nice table, which can be made pretty in due course
        //This is very ugly but hopefully won't be too slow...
        //Need to make sure that the table is made afresh each time.
        let outputTable = document.getElementById("outputTable");
        //Clear the existing results
        let rows = outputTable.rows;
        let i = rows.length;
        let newRow, newCell, newText;
        let depTime, arrTime, nchanges;
        let journeyTime = new Date()
        while (--i) {
            outputTable.deleteRow(i)
        }

        for (let i = 0; i < trainData.length; i ++){
            newRow = outputTable.insertRow(-1);

            newCell = newRow.insertCell();
            newText = document.createTextNode(toTime(trainData[i].dep_time));           
            newCell.appendChild(newText);

            newCell = newRow.insertCell();
            newText = document.createTextNode(toTime(trainData[i].arr_time));
            newCell.appendChild(newText);
          
            newCell = newRow.insertCell();
            newText = document.createTextNode(toPrice(trainData[i].price));
            newCell.appendChild(newText);

            //Calculate the journey time here, as that's a useful thing to have
            journeyTime = findJourneyTime(trainData[i].dep_time, trainData[i].arr_time)
            newCell = newRow.insertCell();
            if (journeyTime.getUTCHours() < 1){
                newText = document.createTextNode(journeyTime.getUTCMinutes() + "m");
            } else {
                newText = document.createTextNode(journeyTime.getUTCHours() + "h" + journeyTime.getUTCMinutes());
            }
            newCell.appendChild(newText);

            nchanges = trainData[i].nchanges;
            newCell = newRow.insertCell();
            newText = document.createTextNode(nchanges)
            newCell.appendChild(newText)
            //Add the detail boxes

            newRow.classList.add('clickable');

            let detailsRow = outputTable.insertRow();
            detailsRow.classList.add('details');
            let cell = detailsRow.insertCell();

            cell.colSpan = 5;
            cell.innerHTML = trainAdditionalInfo(i, trainData)

            newRow.addEventListener('click', () => {
                detailsRow.style.display =
                detailsRow.style.display === 'table-row' ? 'none' : 'table-row';
            });

            detailsRow.addEventListener('click', () => {
                detailsRow.style.display =
                detailsRow.style.display === 'table-row' ? 'none' : 'table-row';
            });
        }
    }

    function trainAdditionalInfo(trainNumber, trainData){
        //Returns the additional info for the train in nicely formatted html
        //Number of tickets and things. Might need a station lookup?
        let returnString = '<div>'
        let rowString = ''  //For each row. This is a bit tricky to format probably
        const nsplits = trainData[trainNumber].split_stations.length
        if (nsplits == 0) {
            returnString += trainData[trainNumber].origin + '-' + trainData[trainNumber].destination + '&nbsp&nbsp' + toTime(trainData[trainNumber].dep_time) + '-' + toTime(trainData[trainNumber].arr_time) + '&nbsp&nbsp' + toPrice(trainData[trainNumber].split_prices[0])
        } else {
            returnString += trainData[trainNumber].origin + '-' + trainData[trainNumber].split_stations[0] + '&nbsp&nbsp' + toTime(trainData[trainNumber].dep_time) + '-' + toTime(trainData[trainNumber].split_arrs[0]) + '&nbsp&nbsp' + toPrice(trainData[trainNumber].split_prices[0])
            returnString += '<br>'
            //Then middle splits (if any). Not sure how to test this very well...
            for (let i = 0; i < nsplits - 1; i++){
            returnString += trainData[trainNumber].split_stations[i]+ '-' + trainData[trainNumber].split_stations[i+1] + '&nbsp&nbsp' + toTime(trainData[trainNumber].split_deps[i]) + '-' + toTime(trainData[trainNumber].split_arrs[i+1]) + '&nbsp&nbsp' + toPrice(trainData[trainNumber].split_prices[i+1])
            returnString += '<br>'
            }
            returnString += trainData[trainNumber].split_stations[nsplits-1] + '-' + trainData[trainNumber].destination + '&nbsp&nbsp' + toTime(trainData[trainNumber].split_deps[nsplits-1]) + '-' + toTime(trainData[trainNumber].arr_time) + '&nbsp&nbsp' + toPrice(trainData[trainNumber].split_prices[nsplits])
        }

        returnString += '</div>'

        return returnString
    }

    function packageInputData(requestStatus, checkNumber){
        let departMinutes, arriveMinutes
        //This is for taking the input data, checking if it exists and compiling into a 'dictionary' for jsonifying. Not sure what the correct approach here is but I think it's the same as python...
        originStation = document.getElementById('origin-input').value;
        originStation = String(originStation).substring(originStation.length-4,originStation.length-1)
        if (!originStation) {
            originStation = "DHM"
            // console.log("No origin station.");
            // document.getElementById("status-container").innerHTML = "Please input an origin station and try again.";
            // document.getElementById("result-container").innerHTML = "";
            // document.getElementById("outputTable").style.display = "none";
            // return;
        }

        destinationStation = document.getElementById('destination-input').value;
        destinationStation = String(destinationStation).substring(destinationStation.length-4,destinationStation.length-1)
        if (!destinationStation) {
            destinationStation = "YRK"
            // console.log("No destination station.");
            // document.getElementById("status-container").innerHTML = "Please input a destination station and try again.";
            // document.getElementById("result-container").innerHTML = "";
            // document.getElementById("outputTable").style.display = "none";
            // return;
        }

        trainDate = document.getElementById('date-input').value;
        departTime = document.getElementById('depart-time-input').value;
        arriveTime = document.getElementById('arrive-time-input').value;
        
        //Do some checks on the valid times. Need converting to a date for that.
        departMinutes = departTime.substring(0,2) + departTime.substring(3,5)
        if (departTime.substring(0,2) + departTime.substring(3,5) > arriveTime.substring(0,2) + arriveTime.substring(3,5)){
            console.log("Departs after arrives");
            document.getElementById("status-container").innerHTML = "Arrival time must be after departure time.";
            document.getElementById("result-container").innerHTML = "";
            document.getElementById("outputTable").style.display = "none";
            document.getElementById("sort-options").style.display = "none";
            return;
        }

        //If the input is today, check that the departure time isn't earlier than now
        let today = new Date();
        let todayString = today.toISOString().split('T')[0];
        let timeString = String(today.getHours()).padStart(2,'0') + ":" + String(today.getMinutes()).padStart(2,'0')
        if (document.getElementById('date-input').value == todayString && checkNumber == 0){
            if (timeString.substring(0,2) + timeString.substring(3,5) > departTime.substring(0,2) + departTime.substring(3,5)){
                console.log("Departs in the past");
                document.getElementById("status-container").innerHTML = "Departure time must not be in the past.";
                document.getElementById("result-container").innerHTML = "";
                document.getElementById("outputTable").style.display = "none";
                document.getElementById("sort-options").style.display = "none";
                return
            }
        }
        //If this is the first request (status == 0) then print as much. If not keep the current results. Not sure what I meant by that now.
        if (requestStatus == 0){
            document.getElementById("status-container").innerHTML = "Finding direct tickets only...";
            document.getElementById("result-container").innerHTML = "";
            document.getElementById("outputTable").style.display = "none";
            document.getElementById("sort-options").style.display = "none";
        } else if (requestStatus == 1){
            document.getElementById("status-container").innerHTML = "Finding single split tickets. <br> Should take less than 5 minutes but may occasionally be longer.";
            document.getElementById("result-container").innerHTML = "";
            document.getElementById("outputTable").style.display = "none";
            document.getElementById("sort-options").style.display = "none";
        } else if (checkNumber == 0) {
            document.getElementById("status-container").innerHTML = "Finding detailed split tickets. <br> This may take up to half an hour or so but the results below will update as it goes."
            document.getElementById("result-container").innerHTML = "";
            document.getElementById("outputTable").style.display = "none";
            document.getElementById("sort-options").style.display = "none";
        }
        
        //If it's got this far, there are at least origin and destination stations
        //If there is already some train data, send this along with the python so it doesn't need to be done multiple times. Filtering will take longer but I think that's fine.

        if (trainData.length > 0){
            inputParameters = {"requestStatus":requestStatus, "origin":originStation, "destination":destinationStation, "date":trainDate, "departTime": departTime, "arriveTime": arriveTime, "checkNumber": checkNumber, "trainData":trainData};
        } else {
        inputParameters = {"requestStatus":requestStatus, "origin":originStation, "destination":destinationStation, "date":trainDate, "departTime": departTime, "arriveTime": arriveTime, "checkNumber": checkNumber};
        }
        console.log(inputParameters)
        return inputParameters;
    }

</script>
</html>
